# 性能优化

## 自动内存管理

 - 动态内存
    - malloc()
- 自动内存管理(垃圾回收):由程序运行时回收内存
    - 保证内存使用的正确性和安全性：double-free problem,use-after-free problem
- 三个任务
    - 为新对象分配空间
    - 找到存活对象
    - 回收死亡对象的内存空间


## 相关概念


- Auto memory management: 自动内存管理
- Grabage collction: 垃圾回收
- Mutator: 业务线程,分配新对象，修改对象指向关系
- Collector: GC 线程  找到存活对象回收死亡对象的内存空间
- Concurrent GC: 并发 GC mutator和collector可以同时执行
    - collectors 必须感知对象指向关系的改变
- Parallel GC: 并行 GC  支持多个Collectors同时回收多个GC
- Serial GC: 只有一个 collector

## 追踪垃圾回收

- 对象被回收条件：指针指向关系不可达的对象
- 标记根对象
    - 静态变量 全局变量
- 标记：找到可达对象
    - 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
- 清理：所有不可达对象
    - 把存活对象复制到另外的内存空间 make-copying GC
         - 将存活对象从一块内存空间复制到另外一块内存空间，原先的空间可以直接进行对象分配
    - 把死亡对象内存标记为可分配  make-sweep Gc 
        - 将死亡对象所在内存块标记为可分配，使用 free list 管理可分配的空间
    - 移动并且整理存活对象  mark-compact GC 
        -将存活对象复制到同一块内存区域的开头
    
## 分代GC

- 每个对象都有年龄：经历GC次数
- 年轻代：
    - 存活对象少，可以使用copying collection
    - GC 吞吐量高
- 老年代：
    - 对象趋向于一直活着，反复开销大
    - 可以使用 mark-sweep collectioon


## 引用计数

- 每个对象都有一个与之关联的引用数目
- 对象存活的条件：当且仅当引用数大于 0

### 优点
- 内存管理的操作被平摊到程序运行中：指针传递的过程中进行引用计数的增减
- 不需要了解 runtime 的细节：因为不需要标记 GC roots，因此不需要知道哪里是全局变量、线程栈等

### 缺点

- 开销大，因为对象可能会被多线程访问，对引用计数的修改需要原子****操作保证原子性和可见性
- 无法回收环形数据结构
- 每个对象都引入额外存储空间存储引用计数
- 虽然引用计数的操作被平摊到程序运行过程中，但是回收大的数据结构依然可能引发暂停



































