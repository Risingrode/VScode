# Go 内存管理及优化

## Go内存分配--缓存

- 对象分配频率高
- 小对象占比高
- 分配内存比较耗时
    - 路径长：g->m->p->mcache->mspan->memory block-> return pointer
    - pprof:高频繁函数调用之一

## Banlanced GC  (cpu和延时减低4个点)

- 给每个g绑定一块内存(小于128k)，称作GAB
- 用于小对象内存分配
- 使用三指针维护
- 指针碰撞风格对象分配
    - 无需和其它请求分配互斥

 * GAB对Go来说是一个大对象
 * 本质：把多个小对象合并成一个大对象
 * gab内存被延迟释放
    * 方案：移动gab中存活的对象
    * 当gab超过一定阈值时，把存活对象分配到另外的gab中
    * 本质是：用copying GC 管理小对象


## 静态分析

 > 不执行代码，推导程序行为。
    1.程序执行流程
    2.数据在控制流上的传递


### 过程内和过程间分析
    - 过程内分析
        - 仅在函数内分析
    - 过程间分析
        - 考虑参数传递和返回值

## go编译器优化-函数内联

- 内敛：将被调用函数的函数体替换到调用位置
- 优点：
    - 消除函数调用开销
    - 把过程间分析转化为过程内分析
- 缺点：
    - 函数体变大，instruction cache 不友好
    - Go镜像变大

## Beast Mode

- 调整内敛策略，使更多函数被内敛
    - 降低函数调用开销
    - 增加其它优化机会：`逃逸分析`

## 逃逸分析

 > 分析代码中指针作用域，指针在何处可以被访问

### 思路
- 从对象分配出发，沿着控制流，观察数据流
- 若发现指针p在当前作用域s:
    - 作为参数传递给其他函数；
    - 传递给全局变量；
    - 传递给其他的 goroutine;
    - 传递给已逃逸的指针指向的对象；
- 则指针 p 逃逸出 s，反之则没有逃逸出 s.

 > 优化：未逃逸出当前函数的指针指向的对象可以在栈上分配
- 对象在栈上分配和回收很快：移动 sp 即可完成内存的分配和回收；
- 减少在堆上分配对象，降低 GC 负担。




























